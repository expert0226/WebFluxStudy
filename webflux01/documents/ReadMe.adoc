:toc:
:numbered:

= WebFlux 첫 만남

== Spring WebFlux 프로젝트 만들기

* https://start.spring.io/ 에 접속한다.
* Dependencies 에서 Reactive Web 을 선택한다.
* 나머지는 취향의 문제...
** image:./images/001.png[start.spring.io]
* [Generate Project] 버튼을 클릭해서 zip 로 다운로드 받는다.
* 다운로드 반은 zip 파일을 적당한 위치에서 압축 해제한다.
* 본인이 선호하는 IDE 로 프로젝트를 오픈한다.
** image:./images/002.png[build.gradle 를 Open 해 주자]
** image:./images/003.png[Open as Project 를 선택해 주자]
** image:./images/004.png[몇 가지 설정을 조정해 주자]
** image:./images/005.png[Open 완료]

== Rest API 로 Hello WebFlux 찍어 보기

src\main\java\com\heaven\webflux01 폴더 밑 Webflux01Application.java 파일을 열도록 하자.

[soruce,java]
[subs="quotes"]
----
package com.heaven.webflux01;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Webflux01Application {

	public static void main(String[] args) {
		SpringApplication.run(Webflux01Application.class, args);
	}
}
----

웹 브라우저에서 "Hello WebFlux!!!" 라는 문자열을 찍어 보자.

[soruce,java]
[subs="quotes"]
----
package com.heaven.webflux01;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
#import org.springframework.web.bind.annotation.GetMapping;#
#import org.springframework.web.bind.annotation.RestController;#

@SpringBootApplication
#@RestController#
public class Webflux01Application {
    #@GetMapping("/hello")#
    #public String hello() {#
        #return "Hello WebFlux!!!";#
    #}#

	public static void main(String[] args) {
		SpringApplication.run(Webflux01Application.class, args);
	}
}
----

* @RestController 를 클래스 위에 선언해 주었다.
** org.springframework.web.bind.annotation.RestController 를 import 해 주었다.
* hello() 메소드를 추가해 주었다.
** GetMapping 으로 Rest 요청을 처리할 수 있도록 했다.
** org.springframework.web.bind.annotation.GetMapping 을 import 해 주었다.

Webflux01Application 을 실행하자.

Console 에 표시된 로그 중에 중요하게 기억해야 할 것들이 몇가지 살펴보자.

[source,log]
[subs="quotes"]
----
... : Mapped "{[/hello],methods=[GET]}" ...
... : Started HttpServer on /0:0:0:0:0:0:0:0:8080
... : #Netty# started on port(s): 8080
... : Started Webflux01Application in 11.763 seconds (JVM running for 23.812)
----

* Mapped "{[/hello],methods=[GET]}"
** /hello 웹 경로를 GET 방식으로 접근할 수 있다.
* Netty started on port(s): 8080
** Web Server 인 Nettoy 가 8080 포트로 구동되었다.
** Tomcat 이 아니다. Netty 다 그럼 #"Servlet 이여. 안녕!!!"# 이다.

브라우저에서 http://localhost:8080/hello 로 접속해 보자.

** image:./images/006.png[IE 라니... 나의 Chrome 는 소중하니까!]

여기까지 봤을 때 기존 WebMVC 와의 차이는 Tomcat 대신 Netty 를 쓴다는 것 외에는 차이가 없어 보인다.
하지만 그 차이는 사실 매우 크다. 더 이상 Servlet 스펙을 고려하지 않아도 된다는 것이다.
여기에 더해서 내부적으로 많이 변화가 더해졌다.

== Reactor 사용해 보기

WebFlux 는 Reactor 를 사용한다.
Reactor 는 Reactive Streams 의 구현체다. +
Reactive Streams 는 http://www.reactive-streams.org 를 보면 알 수 있다고 한다. +
Reactor 는 http://projectreactor.io/docs/core/release/reference/ 를 보면 알 수 있다고 한다. +
웹문서를 차근 차근 읽어보는 것도 좋은 방법이겠으나 이미 많은 분들이 읽고 정리해 주신 내용으로 핵심만 골라 프로젝트에서 예제를 만들어 가며 이해해 보자.

Reactor 의 핵심은 Mono 와 Flux 이다. +
Mono 는 값을 0 또는 1 개를 갖고 있는 컬렉션이다. +
Flux 는 값을 0 개 이상 갖고 있는 컬렉션이다. +
Mono 와 Flux 를 만드는 가장 쉬운 방법은 just 메소드에 값(들)을 나열하는 것이다.

예제를 만들어 보자.

[soruce,java]
[subs="quotes"]
----
package com.heaven.webflux01;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
#import reactor.core.publisher.Flux;#
#import reactor.core.publisher.Mono;#

@SpringBootApplication
@RestController
public class Webflux01Application {
	@GetMapping("/hello")
	public String hello() {
		return "Hello WebFlux!!!";
	}

	#@GetMapping("/hello/mono")#
	#public Mono<String> helloMono() {#
		#return Mono.just("Hello Mono!!!");#
	#}#

    #@GetMapping("/hello/flux")#
    #public Flux<String> helloFlux() {#
        #return Flux.just(#
            #"Hello Flux!!!",#
            #"Hello Reactor 3!!!",#
            #"Hello Reactive Streams!!!");#
    #}#

	public static void main(String[] args) {
		SpringApplication.run(Webflux01Application.class, args);
	}
}
----

프로젝트를 재실행 후에 각각 브라우저 접근해 보자.

* image:./images/007.png[Hello Mono!!!]
* image:./images/008.png[Hello Flux!!!]

웹 브라우저 사용자 입장에서는 차이가 없다는 것을 알 수 있다. +
개발 입장에서도 차이가 없는 것 같지만... 위에 작성한 코드는 WebMVC 방식을 짬봉해서 만들어진 것이다. +
향후 WebFlux 방식의 코딩으로 순수 함수형 스타일의 코드에 도전을... +
그런데 Reactor 부터 다시 말해, Mono 와 Flux 부터 학습을 좀 해야할 것 같다는...





